/*
*	@file WarningEffects.cpp
*	@brief ダメージエフェクトの管理クラスのソースファイル
*/
#include <pch.h>
#include "WarningEffects.h"

/*
*	@brief コンストラクタ
*	@param[in] resources 共通リソース
*	@return なし
*/
WarningEffects::WarningEffects(CommonResources* resources)
	: m_commonResources(resources)
	, m_pPlayer{}
	, m_pEnemyManager{}
{}

/*
*	@brief デストラクタ
*	@return なし
*/
WarningEffects::~WarningEffects() {}

/*
*	@brief 初期化
*	@param[in] pPlayer プレイヤーのポインタ
*	@param[in] pEnemyManager 敵のポインタ
*	@return なし
*/
void WarningEffects::Initialize(Player* pPlayer, EnemyManager* pEnemyManager)
{
	m_pPlayer = pPlayer;// プレイヤーのポインターを受け取る
	m_pEnemyManager = pEnemyManager;// 敵のポインターを受け取る
}

/*
*	@brief ダメージを受けた時の演出を生成
*	@return なし
*/
void WarningEffects::CreateDamageEffects()
{
	std::unique_ptr<DamageEffect> damageEffect = std::make_unique<DamageEffect>(m_commonResources);// ダメージエフェクトの生成
	damageEffect->SetPlayer(m_pPlayer);// プレイヤーのポインタを設定
	damageEffect->SetEffectType(DamageEffect::EffectType::DAMAGE);// エフェクトタイプを設定
	damageEffect->Initialize();// 初期化
	m_pDamageEffect.push_back(std::move(damageEffect));// ダメージエフェクトをリストに追加
}

/*
*	@brief 敵が攻撃してきた時の演出を生成
*	@return なし
*/
void WarningEffects::CreateInComingEnemy()
{
	for (auto& attackingEnemy : m_pEnemyManager->GetEnemies())
	{
		if (!attackingEnemy->GetIsAttack())continue;// 攻撃フラグが立っていなかったら次のループへ
		std::unique_ptr<DamageEffect> warningEffect = std::make_unique<DamageEffect>(m_commonResources);// ダメージエフェクトの生成
		warningEffect->SetPlayer(m_pPlayer);// プレイヤーのポインタを設定
		warningEffect->SetEffectType(DamageEffect::EffectType::INCOMINGENEMY);// エフェクトタイプを設定
		warningEffect->SetEnemy(attackingEnemy.get());// 攻撃してきた敵のポインタを設定
		warningEffect->Initialize();// 初期化
		m_pDamageEffect.push_back(std::move(warningEffect));// ダメージエフェクトをリストに追加

	}

}

/*
*	@brief 更新
*	@param[in] elapsedTime 経過時間
*	@return なし
*/
void WarningEffects::Update(float elapsedTime)
{
	std::vector<std::unique_ptr<DamageEffect>> newDamageEffect;// 新しいダメージエフェクト
	for (auto& damageEffect : m_pDamageEffect)
	{
		damageEffect->Update(elapsedTime);// ダメージエフェクトを更新
		// 再生が終わったダメージエフェクトだったらそのエフェクトを完全に破棄
		if (damageEffect->Destroy())// ダメージエフェクトの破棄フラグがtrueだったら
		{
			damageEffect.reset();// ダメージエフェクトを破棄
			continue;// 次のループへ
		}
		newDamageEffect.push_back(std::move(damageEffect));// 新しいリストにダメージエフェクトを追加
	}
	m_pDamageEffect = std::move(newDamageEffect);// ダメージエフェクトを新しいリストに置き換える
}
/*
*	@brief 描画
*	@return なし
*/
void WarningEffects::Render()
{
	for (auto& damageEffect : m_pDamageEffect)if (damageEffect->GetPlayEffect())damageEffect->Render();	// ダメージエフェクトを更新する
}
